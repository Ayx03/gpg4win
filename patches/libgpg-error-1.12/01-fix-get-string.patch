#! /bin/sh
patch -p1 -l -f $* < $0
exit $?

From 52e1f2e131b422fdb66abeaf4a8f084689b39bf7 Mon Sep 17 00:00:00 2001
From: Werner Koch <wk@gnupg.org>
Date: Mon, 15 Jul 2013 15:31:55 +0200
Subject: [PATCH] w32: Fix corrupted string output.

* src/w32-gettext.c (get_string): Pass the nul of the utf-8 string to
the conversion function but keep TRANSLEN without the nul.
--

The bug first occurred on Windows 8 but it is a real thing.  Assuming
that a malloced buffer is zeroed out is not solid assumptions ;-)
---
 src/w32-gettext.c |   22 ++++++++++++++++++----
 1 files changed, 18 insertions(+), 4 deletions(-)

diff --git a/src/w32-gettext.c b/src/w32-gettext.c
index 936cafe..89f505d 100644
--- a/src/w32-gettext.c
+++ b/src/w32-gettext.c
@@ -1617,6 +1617,17 @@ get_string (struct loaded_domain *domain, uint32_t idx,
                 + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset));
       plen_utf8 = SWAPIT(domain->must_swap, domain->trans_tab[idx].length);

+      /* We need to include the nul, so that the utf8->wchar->native
+         conversion chain works correctly and the nul is stored after
+         the conversion. */
+      if (p_utf8[plen_utf8])
+        {
+          trans = "ERROR in MO file"; /* Terminating zero is missing.  */
+          translen = 0;
+          goto leave;
+        }
+      plen_utf8++;
+
       buf = utf8_to_native (p_utf8, plen_utf8, &buflen);
       if (!buf)
         {
@@ -1640,10 +1651,10 @@ get_string (struct loaded_domain *domain, uint32_t idx,
           /* There is not enough space for the translation (or for
              whatever reason an empty string is used): Store it in the
              overflow_space and mark that in the mapped array.
-             Because UTF-8 strings are in general shorter than the
-             Windows 2 byte encodings, we expect that this won't
-             happen too often (if at all) and thus we use a linked
-             list to manage this space. */
+             Because UTF-8 strings are in general longer than the
+             Windows native encoding, we expect that this won't happen
+             too often and thus we use a linked list to manage this
+             space. */
           os = jnlib_malloc (sizeof *os + buflen);
           if (os)
             {
@@ -1662,6 +1673,8 @@ get_string (struct loaded_domain *domain, uint32_t idx,
               translen = 0;
             }
         }
+      if (translen)
+        translen--;  /* TRANSLEN shall be the size without the nul.  */
       jnlib_free (buf);
     }
   else if (domain->mapped[idx] == 1)
@@ -1688,6 +1701,7 @@ get_string (struct loaded_domain *domain, uint32_t idx,
       translen = domain->mapped[idx];
     }

+ leave:
   if (use_plural && translen)
     return get_plural (trans, translen, nplural);
   else
--
1.7.7.1
