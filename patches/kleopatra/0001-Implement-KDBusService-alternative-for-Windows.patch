#! /bin/sh
patch -p1 -l -f $* < $0
exit $?

From 243a5fccc82d7b398ec3cc8509e0900eac5d35af Mon Sep 17 00:00:00 2001
From: Andre Heinecke <aheinecke@intevation.de>
Date: Fri, 29 Jan 2016 17:00:54 +0100
Subject: [PATCH 1/5] Implement KDBusService alternative for Windows

Instead of using KDBusService we can just use Window
Messages to communicate with other processes on Windows.
---
 CMakeLists.txt                    |  15 ++-
 autotests/CMakeLists.txt          |  13 +++
 autotests/kuniqueservicetest.cpp  | 177 ++++++++++++++++++++++++++++++
 src/kleopatraapplication.cpp      |   2 +
 src/kwatchgnupg/CMakeLists.txt    |   6 ++
 src/kwatchgnupg/main.cpp          |   4 +-
 src/main.cpp                      |   7 +-
 src/utils/kuniqueservice.h        |  91 ++++++++++++++++
 src/utils/kuniqueservice_dbus.cpp |  64 +++++++++++
 src/utils/kuniqueservice_win.cpp  | 219 ++++++++++++++++++++++++++++++++++++++
 10 files changed, 591 insertions(+), 7 deletions(-)
 create mode 100644 autotests/CMakeLists.txt
 create mode 100644 autotests/kuniqueservicetest.cpp
 create mode 100644 src/utils/kuniqueservice.h
 create mode 100644 src/utils/kuniqueservice_dbus.cpp
 create mode 100644 src/utils/kuniqueservice_win.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2fddf22..7970ffe 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -32,7 +32,6 @@ include(ECMQtDeclareLoggingCategory)

 # Find KF5 packages
 find_package(KF5Codecs ${KF5_VERSION} CONFIG REQUIRED)
-find_package(KF5DBusAddons ${KF5_VERSION} CONFIG REQUIRED)
 find_package(KF5KCMUtils ${KF5_VERSION} CONFIG REQUIRED)
 find_package(KF5Config ${KF5_VERSION} CONFIG REQUIRED)
 find_package(KF5I18n ${KF5_VERSION} CONFIG REQUIRED)
@@ -45,6 +44,19 @@ find_package(KF5DocTools REQUIRED)

 set_package_properties(KF5DocTools PROPERTIES DESCRIPTION "Documentation tools" TYPE OPTIONAL PURPOSE "Required to generate Kleopatra documentation.")

+# Optional packages
+if (WIN32)
+  # Only a replacement available for Windows so this
+  # is required on other platforms.
+  find_package(KF5DBusAddons ${KF5_VERSION} CONFIG)
+  set_package_properties(KF5DBusAddons PROPERTIES DESCRIPTION "Support library to work with DBus"
+                         PURPOSE "DBus session integration"
+                         URL "http://inqlude.org/libraries/kdbusaddons.html"
+                         TYPE OPTIONAL)
+else()
+  find_package(KF5DBusAddons ${KF5_VERSION} CONFIG REQUIRED)
+endif()
+
 # Kdepimlibs packages
 find_package(KF5Libkleo ${LIBKLEO_VERSION} CONFIG REQUIRED)
 find_package(KF5Mime ${KMIME_VERSION} CONFIG REQUIRED)
@@ -116,6 +128,7 @@ add_subdirectory(src)

 if(BUILD_TESTING)
     add_subdirectory(tests)
+    add_subdirectory(autotests)
 endif()
 install( FILES kleopatra.categories DESTINATION ${KDE_INSTALL_CONFDIR} )

diff --git a/autotests/CMakeLists.txt b/autotests/CMakeLists.txt
new file mode 100644
index 0000000..b987250
--- /dev/null
+++ b/autotests/CMakeLists.txt
@@ -0,0 +1,13 @@
+set(EXECUTABLE_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR})
+
+if (KF5DBusAddons_FOUND)
+    set(kuniqueservicetest_src kuniqueservicetest.cpp ../utils/kuniqueservice_dbus.cpp)
+else()
+    set(kuniqueservicetest_src kuniqueservicetest.cpp ../utils/kuniqueservice_win.cpp)
+endif()
+
+ecm_qt_declare_logging_category(kuniqueservicetest_src HEADER kleopatra_debug.h IDENTIFIER KLEOPATRA_LOG CATEGORY_NAME log_kleopatra)
+add_executable(kuniqueservicetest ${kuniqueservicetest_src})
+add_test(kuniqueservicetest kuniqueservicetest)
+ecm_mark_as_test(kuniqueservicetest)
+target_link_libraries(kuniqueservicetest Qt5::Test ${_kleopatra_dbusaddons_libs})
diff --git a/autotests/kuniqueservicetest.cpp b/autotests/kuniqueservicetest.cpp
new file mode 100644
index 0000000..1a83a5e
--- /dev/null
+++ b/autotests/kuniqueservicetest.cpp
@@ -0,0 +1,177 @@
+/* This file is part of Kleopatra
+
+   Copyright (c) 2016 Intevation GmbH
+
+   It is based on libkdbus kdbusservicetest which is:
+
+   Copyright (c) 1999 Waldo Bastian <bastian@kde.org>
+   Copyright (c) 2011 David Faure <faure@kde.org>
+   Copyright (c) 2011 Kevin Ottens <ervin@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+/* The main modification in this test is that every activateRequested
+ * call needs to set the exit code to signal the application it's done. */
+
+#include <QCoreApplication>
+#include <QDebug>
+#include <QDir>
+#include <QFile>
+#include <QMetaObject>
+#include <QProcess>
+#include <QTimer>
+
+#include "utils/kuniqueservice.h"
+
+#include <stdio.h>
+
+class TestObject : public QObject
+{
+    Q_OBJECT
+public:
+    TestObject(KUniqueService *service)
+        : m_proc(Q_NULLPTR), m_callCount(0),
+          m_service(service)
+    {}
+
+    ~TestObject()
+    {
+        if (m_proc) {
+            m_proc->waitForFinished();
+        }
+    }
+
+    int callCount() const
+    {
+        return m_callCount;
+    }
+
+private Q_SLOTS:
+    void slotActivateRequested(const QStringList &args, const QString &workingDirectory)
+    {
+        Q_UNUSED(workingDirectory);
+        qDebug() << "Application executed with args" << args;
+
+        ++m_callCount;
+
+        if (m_callCount == 1) {
+            Q_ASSERT(args.count() == 1);
+            Q_ASSERT(args.at(0) == QLatin1String("dummy call"));
+            m_service->setExitValue(0);
+        } else if (m_callCount == 2) {
+            Q_ASSERT(args.count() == 2);
+            Q_ASSERT(args.at(1) == QLatin1String("bad call"));
+            m_service->setExitValue(4);
+        } else if (m_callCount == 3) {
+            Q_ASSERT(args.count() == 3);
+            Q_ASSERT(args.at(1) == QLatin1String("real call"));
+            Q_ASSERT(args.at(2) == QLatin1String("second arg"));
+            m_service->setExitValue(0);
+            // OK, all done, quit
+            QCoreApplication::instance()->quit();
+        }
+    }
+
+    void slotProcessFinished(int exitCode, QProcess::ExitStatus exitStatus)
+    {
+        Q_UNUSED(exitStatus)
+        qDebug() << "Process exited with code" << exitCode;
+        m_proc = 0;
+        if (m_callCount == 2) {
+            Q_ASSERT(exitCode == 4);
+            secondCall();
+        }
+    }
+
+    void firstCall()
+    {
+        QStringList args;
+        args << QStringLiteral("bad call");
+        executeNewChild(args);
+    }
+
+    void secondCall()
+    {
+        QStringList args;
+        args << QStringLiteral("real call") << QStringLiteral("second arg");
+        executeNewChild(args);
+    }
+
+private:
+    void executeNewChild(const QStringList &args)
+    {
+        // Duplicated from kglobalsettingstest.cpp - make a shared helper method?
+        m_proc = new QProcess(this);
+        connect(m_proc, SIGNAL(finished(int,QProcess::ExitStatus)),
+                this, SLOT(slotProcessFinished(int,QProcess::ExitStatus)));
+        QString appName = QStringLiteral("kuniqueservicetest");
+#ifdef Q_OS_WIN
+        appName += QStringLiteral(".exe");
+#else
+        if (QFile::exists(appName + QStringLiteral(".shell"))) {
+            appName = QStringLiteral("./") + appName + QStringLiteral(".shell");
+        } else {
+            Q_ASSERT(QFile::exists(appName));
+            appName = QStringLiteral("./") + appName;
+        }
+#endif
+        qDebug() << "about to run" << appName << args;
+        m_proc->start(appName, args);
+    }
+
+    QProcess *m_proc;
+    int m_callCount;
+    KUniqueService *m_service;
+};
+
+int main(int argc, char *argv[])
+{
+    QCoreApplication a(argc, argv);
+
+    QCoreApplication::setApplicationName(QStringLiteral("kuniqueservicetest"));
+    QCoreApplication::setOrganizationDomain(QStringLiteral("kde.org"));
+
+    KUniqueService service;
+    TestObject testObject(&service);
+    QObject::connect(&service, SIGNAL(activateRequested(QStringList, QString)),
+                     &testObject, SLOT(slotActivateRequested(QStringList, QString)));
+
+    // Testcase for the problem coming from the old fork-on-startup solution:
+    // the "Activate" D-Bus call would time out if the app took too much time
+    // to be ready.
+    //printf("Sleeping.\n");
+    //sleep(200);
+    QStringList args;
+    args << QStringLiteral("dummy call");
+
+    QMetaObject::invokeMethod(&service, "activateRequested",
+                              Qt::QueuedConnection,
+                              Q_ARG(QStringList, args),
+                              Q_ARG(QString, QDir::currentPath()));
+    QTimer::singleShot(400, &testObject, SLOT(firstCall()));
+
+    qDebug() << "Running.";
+    a.exec();
+    qDebug() << "Terminating.";
+
+    Q_ASSERT(testObject.callCount() == 3);
+    const bool ok = testObject.callCount() == 3;
+
+    return ok ? 0 : 1;
+}
+
+#include "kuniqueservicetest.moc"
+
diff --git a/src/kleopatraapplication.cpp b/src/kleopatraapplication.cpp
index f4b3b55..1f58c54 100644
--- a/src/kleopatraapplication.cpp
+++ b/src/kleopatraapplication.cpp
@@ -236,7 +236,9 @@ void KleopatraApplication::slotActivateRequested(const QStringList &arguments,
     if (!err.isEmpty()) {
         KMessageBox::sorry(NULL, err.toHtmlEscaped(), i18n("Failed to execute command"));
         Q_EMIT setExitValue(1);
+        return;
     }
+    Q_EMIT setExitValue(0);
 }

 QString KleopatraApplication::newInstance(const QCommandLineParser &parser,
diff --git a/src/kwatchgnupg/CMakeLists.txt b/src/kwatchgnupg/CMakeLists.txt
index beda545..338cad5 100644
--- a/src/kwatchgnupg/CMakeLists.txt
+++ b/src/kwatchgnupg/CMakeLists.txt
@@ -9,6 +9,12 @@ set(kwatchgnupg_SRCS
   tray.cpp
   main.cpp
 )
+if (KF5DBusAddons_FOUND)
+  set(kwatchgnupg_SRCS ${kwatchgnupg_SRCS} ${kleopatra_SOURCE_DIR}/utils/kuniqueservice_dbus.cpp)
+else()
+  set(kwatchgnupg_SRCS ${kwatchgnupg_SRCS} ${kleopatra_SOURCE_DIR}/utils/kuniqueservice_win.cpp)
+endif()
+
 ecm_qt_declare_logging_category(kwatchgnupg_SRCS HEADER kwatchgnupg_debug.h IDENTIFIER KWATCHGNUPG_LOG CATEGORY_NAME log_kwatchgnupg)
 qt5_add_resources(kwatchgnupg_SRCS kwatchgnupg.qrc)

diff --git a/src/kwatchgnupg/main.cpp b/src/kwatchgnupg/main.cpp
index af7a4fd..78d2d7f 100644
--- a/src/kwatchgnupg/main.cpp
+++ b/src/kwatchgnupg/main.cpp
@@ -35,7 +35,7 @@
 #include "aboutdata.h"
 #include "kwatchgnupgmainwin.h"
 #include <kdelibs4configmigrator.h>
-#include <KDBusService>
+#include "utils/kuniqueservice.h"

 #include <kmessagebox.h>
 #include <KLocalizedString>
@@ -63,7 +63,7 @@ int main(int argc, char **argv)
     parser.process(app);
     aboutData.processCommandLine(&parser);

-    KDBusService service(KDBusService::Unique);
+    KUniqueService service;

     KWatchGnuPGMainWindow *mMainWin = new KWatchGnuPGMainWindow();
     mMainWin->show();
diff --git a/src/main.cpp b/src/main.cpp
index 4b909d5..4a91273 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -43,6 +43,7 @@

 #include <utils/gnupg-helper.h>
 #include <utils/archivedefinition.h>
+#include "utils/kuniqueservice.h"

 #ifdef HAVE_USABLE_ASSUAN
 # include <uiserver/uiserver.h>
@@ -74,8 +75,6 @@ class UiServer;
 #include "kleopatra_debug.h"
 #include "kleopatra_options.h"

-#include <KDBusService>
-
 #include <KLocalizedString>
 #include <kiconloader.h>
 #include <QSplashScreen>
@@ -213,8 +212,8 @@ int main(int argc, char **argv)

     KLocalizedString::setApplicationDomain("kleopatra");

-    KDBusService service(KDBusService::Unique);
-    QObject::connect(&service, &KDBusService::activateRequested,
+    KUniqueService service;
+    QObject::connect(&service, &KUniqueService::activateRequested,
                      &app, &KleopatraApplication::slotActivateRequested);
     QObject::connect(&app, &KleopatraApplication::setExitValue,
     &service, [&service](int i) {
diff --git a/src/utils/kuniqueservice.h b/src/utils/kuniqueservice.h
new file mode 100644
index 0000000..074cf01
--- /dev/null
+++ b/src/utils/kuniqueservice.h
@@ -0,0 +1,91 @@
+#ifndef KUNIQUESERVICE_H
+#define KUNIQUESERVICE_H
+/*
+    kuniqueservice.h
+
+    This file is part of Kleopatra, the KDE keymanager
+    Copyright (c) 2016 Intevation GmbH
+
+    Kleopatra is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    Kleopatra is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+#include <QObject>
+#include <QString>
+#include <QStringList>
+
+/**
+ * This class can be used to create a unique service and redirect calls
+ * to this service similarly to KDBusService(KDBusService::Unique).
+ * @code
+ *   YourApplication app(argc, argv);
+ *
+ *   KUniqueService service;
+ *   QObject::connect(&service, &KUniqueService::activateRequested,
+ *                    &app, &YourApplication::slotActivateRequested);
+ *   QObject::connect(&app, &YourApplication::setExitValue,
+ *   &service, [&service](int i) {
+ *       service.setExitValue(i);
+ *   });
+ * @endcode
+ * This will redirect calls to running instances over the
+ * the slotActivateRequested. When you set the exit
+ * value the calling process will afterwards exit with the
+ * code provided.
+ * If you do not set the exit value the application will not
+ * be terminated.
+ * @author Andre Heinecke (aheinecke@intevation.org)
+ */
+class KUniqueService : public QObject
+{
+    Q_OBJECT
+public:
+    /**
+     * Default constructor
+     */
+    KUniqueService();
+
+public Q_SLOTS:
+    /**
+     * Set the exit @p code the second app should use to terminate.
+     * If unset it exits with 0.
+     * @param code The exit code.
+     */
+    void setExitValue(int code);
+
+Q_SIGNALS:
+    void activateRequested(const QStringList &arguments,
+                           const QString &workingDirectory);
+
+private:
+    void emitActivateRequested(const QStringList &arguments,
+                               const QString &workingDirectory)
+    {
+        Q_EMIT activateRequested(arguments, workingDirectory);
+    }
+    class KUniqueServicePrivate;
+    Q_DECLARE_PRIVATE(KUniqueService)
+    KUniqueServicePrivate *d_ptr;
+};
+#endif // KUNIQUESERVICE_H
diff --git a/src/utils/kuniqueservice_dbus.cpp b/src/utils/kuniqueservice_dbus.cpp
new file mode 100644
index 0000000..cf4ef96
--- /dev/null
+++ b/src/utils/kuniqueservice_dbus.cpp
@@ -0,0 +1,64 @@
+/*
+    kuniqueservice_dbus.cpp
+
+    This file is part of Kleopatra, the KDE keymanager
+    Copyright (c) 2016 Intevation GmbH
+
+    Kleopatra is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    Kleopatra is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "kuniqueservice.h"
+#include <KDBusService>
+
+class KUniqueService::KUniqueServicePrivate
+{
+    Q_DISABLE_COPY(KUniqueServicePrivate)
+
+public:
+    KUniqueServicePrivate(KUniqueService *q) : mService(KDBusService::Unique)
+    {
+        QObject::connect(&mService, &KDBusService::activateRequested,
+                         q, &KUniqueService::activateRequested);
+    }
+
+    void setExitValue(int code)
+    {
+        mService.setExitValue(code);
+    }
+
+private:
+    KDBusService mService;
+};
+
+KUniqueService::KUniqueService() : d_ptr(new KUniqueServicePrivate(this)) {}
+
+void KUniqueService::setExitValue(int code)
+{
+    Q_D(KUniqueService);
+    d->setExitValue(code);
+}
+
+#include "moc_kuniqueservice.cpp"
diff --git a/src/utils/kuniqueservice_win.cpp b/src/utils/kuniqueservice_win.cpp
new file mode 100644
index 0000000..2ea830e
--- /dev/null
+++ b/src/utils/kuniqueservice_win.cpp
@@ -0,0 +1,219 @@
+/*
+    kuniqueservice_win.cpp
+
+    This file is part of Kleopatra, the KDE keymanager
+    Copyright (c) 2016 Intevation GmbH
+
+    Kleopatra is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    Kleopatra is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "kuniqueservice.h"
+
+#include <QCoreApplication>
+#include <QDataStream>
+#include <QDir>
+
+#include "kleopatra_debug.h"
+#include <windows.h>
+
+#define MY_DATA_TYPE 12
+
+class KUniqueService::KUniqueServicePrivate
+{
+    Q_DECLARE_PUBLIC(KUniqueService)
+    Q_DISABLE_COPY(KUniqueServicePrivate)
+
+private:
+    KUniqueService *q_ptr;
+    HWND mResponder;
+    HANDLE mCurrentProcess;
+
+    const QString getWindowName() const
+    {
+        return QCoreApplication::applicationName() + QStringLiteral("Responder");
+    }
+
+    HWND getForeignResponder() const
+    {
+        const QString qWndName = getWindowName();
+        wchar_t *wndName = (wchar_t *)qWndName.utf16();
+        HWND ret = FindWindow(wndName, wndName);
+        qCDebug(KLEOPATRA_LOG) << "Responder handle:" << ret;
+        return ret;
+    }
+
+    void createResponder()
+    {
+        WNDCLASS windowClass;
+        const QString qWndName = getWindowName();
+        wchar_t *wndName = (wchar_t*)qWndName.utf16();
+        windowClass.style = CS_GLOBALCLASS | CS_DBLCLKS;
+        windowClass.lpfnWndProc = windowProc;
+        windowClass.hInstance   = (HINSTANCE) GetModuleHandle(NULL);
+        windowClass.lpszClassName = wndName;
+        windowClass.hIcon = Q_NULLPTR;
+        windowClass.hCursor = Q_NULLPTR;
+        windowClass.hbrBackground = Q_NULLPTR;
+        windowClass.lpszMenuName = Q_NULLPTR;
+        windowClass.cbClsExtra = 0;
+        windowClass.cbWndExtra = 0;
+        RegisterClass(&windowClass);
+        mResponder = CreateWindow(wndName, wndName,
+                                  0, 0, 0, 10, 10, Q_NULLPTR, Q_NULLPTR,
+                                  (HINSTANCE)GetModuleHandle(NULL), Q_NULLPTR);
+        qCDebug(KLEOPATRA_LOG) << "Created responder: " << qWndName
+                               << " with handle: " << mResponder;
+    }
+
+    void handleRequest(const COPYDATASTRUCT *cds)
+    {
+        Q_Q(KUniqueService);
+        if (cds->dwData != MY_DATA_TYPE) {
+            qCDebug(KLEOPATRA_LOG) << "Responder called with invalid data type:"
+                                   << cds->dwData;
+            return;
+        }
+        if (mCurrentProcess) {
+            qCDebug(KLEOPATRA_LOG) << "Already serving. Terminating process: "
+                                   << mCurrentProcess;
+            setExitValue(42);
+        }
+        const QByteArray serialized(static_cast<const char*>(cds->lpData),
+                                    cds->cbData);
+        QDataStream ds(serialized);
+        quint32 curProc;
+        ds >> curProc;
+        mCurrentProcess = (HANDLE) curProc;
+        QString workDir;
+        ds >> workDir;
+        QStringList args;
+        ds >> args;
+        qCDebug(KLEOPATRA_LOG) << "Proccess handle: " << mCurrentProcess
+                               << " requests activate with args "
+                               << args;
+        q->emitActivateRequested(args, workDir);
+        return;
+    }
+
+    KUniqueServicePrivate(KUniqueService *q) : q_ptr(q), mResponder(Q_NULLPTR),
+                                               mCurrentProcess(Q_NULLPTR)
+    {
+        HWND responder = getForeignResponder();
+        if (!responder) {
+            // We are the responder
+            createResponder();
+            return;
+        }
+        // We are the client
+
+        QByteArray serialized;
+        QDataStream ds(&serialized, QIODevice::WriteOnly);
+        DWORD targetId = 0;
+        GetWindowThreadProcessId(responder, &targetId);
+        if (!targetId) {
+            qCDebug(KLEOPATRA_LOG) << "No process id of responder window";
+            return;
+        }
+        HANDLE targetHandle = OpenProcess(PROCESS_DUP_HANDLE, FALSE, targetId);
+        if (!targetHandle) {
+            qCDebug(KLEOPATRA_LOG) << "No target handle. Err: " << GetLastError();
+        }
+
+        // To allow the other process to terminate the process
+        // needs a handle to us with the required access.
+        if (!DuplicateHandle(GetCurrentProcess(),
+                             GetCurrentProcess(),
+                             targetHandle,
+                             &mCurrentProcess,
+                             0,
+                             FALSE,
+                             DUPLICATE_SAME_ACCESS)) {
+            qCDebug(KLEOPATRA_LOG) << "Failed to duplicate handle";
+        }
+        CloseHandle(targetHandle);
+
+        ds << (qint32) mCurrentProcess
+           << QDir::currentPath()
+           << QCoreApplication::arguments();
+        COPYDATASTRUCT cds;
+        cds.dwData = MY_DATA_TYPE;
+        cds.cbData = serialized.size();
+        cds.lpData = serialized.data();
+
+        qCDebug(KLEOPATRA_LOG) << "Sending message to existing Window.";
+        SendMessage(responder, WM_COPYDATA, 0, (LPARAM) &cds);
+        // Usually we should be terminated while sending the message.
+        qCDebug(KLEOPATRA_LOG) << "Send message returned.";
+    }
+
+    static KUniqueServicePrivate *instance(KUniqueService *q) {
+        static KUniqueServicePrivate *self;
+        if (self) {
+            return self;
+        }
+
+        self = new KUniqueServicePrivate(q);
+        return self;
+    }
+
+    static LRESULT CALLBACK windowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
+    {
+        if (message == WM_COPYDATA)
+        {
+            const COPYDATASTRUCT *cds = (COPYDATASTRUCT*)lParam;
+            // windowProc must be static so the singleton pattern although
+            // it doesn't make much sense in here.
+            instance(Q_NULLPTR)->handleRequest(cds);
+            return 0;
+        }
+        return DefWindowProc(hWnd, message, wParam, lParam);
+    }
+
+    ~KUniqueServicePrivate()
+    {
+        if (mResponder) {
+            DestroyWindow(mResponder);
+        }
+    }
+
+    void setExitValue(int code)
+    {
+        TerminateProcess(mCurrentProcess, (unsigned int) code);
+        mCurrentProcess = Q_NULLPTR;
+    }
+};
+
+
+KUniqueService::KUniqueService() : d_ptr(KUniqueServicePrivate::instance(this))
+{
+}
+
+void KUniqueService::setExitValue(int code)
+{
+    Q_D(KUniqueService);
+    d->setExitValue(code);
+}
+#include "moc_kuniqueservice.cpp"
--
2.1.4
