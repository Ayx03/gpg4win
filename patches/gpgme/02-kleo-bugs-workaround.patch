#! /bin/sh
patch -p0 -f $* < $0
exit $?

Work around bugs in kleopatra 20080706.

diff -rup src/keylist.c src/keylist.c
--- src/keylist.c	2008-01-28 19:06:04.000000000 +0100
+++ src/keylist.c	2008-07-08 21:16:39.000000000 +0200
@@ -918,6 +918,14 @@ gpgme_op_keylist_end (gpgme_ctx_t ctx)
   if (!ctx)
     return gpg_error (GPG_ERR_INV_VALUE);
 
+  /* Work around missing gpgme_release in kleopatra, which creates
+     dangling gpgsm processes.  */
+  if (ctx->engine)
+    {
+      _gpgme_engine_release (ctx->engine);
+      ctx->engine = NULL;
+    }
+
   return 0;
 }
 
diff -rup src/w32-io.c src/w32-io.c
--- src/w32-io.c	2008-06-26 15:03:27.000000000 +0200
+++ src/w32-io.c	2008-07-08 18:20:12.000000000 +0200
@@ -53,8 +53,8 @@
 #define READBUF_SIZE 4096
 #define WRITEBUF_SIZE 4096
 #define PIPEBUF_SIZE  4096
-#define MAX_READERS 20
-#define MAX_WRITERS 20
+#define MAX_READERS 40
+#define MAX_WRITERS 40
 
 static struct
 {
diff -rup src/wait-global.c src/wait-global.c
--- src/wait-global.c	2008-07-04 16:15:41.000000000 +0200
+++ src/wait-global.c	2008-07-08 21:15:03.000000000 +0200
@@ -386,5 +386,13 @@ gpgme_wait (gpgme_ctx_t ctx, gpgme_error
     }
   while (hang);
 
+  /* Work around missing gpgme_release in kleopatra, which creates
+     dangling gpgsm processes.  */
+  if (ctx && ctx->engine)
+    {
+      _gpgme_engine_release (ctx->engine);
+      ctx->engine = NULL;
+    }
+
   return ctx;
 }
diff -rup src/wait-private.c src/wait-private.c
--- src/wait-private.c	2008-07-04 16:15:41.000000000 +0200
+++ src/wait-private.c	2008-07-08 21:17:05.000000000 +0200
@@ -31,6 +31,7 @@
 #include "ops.h"
 #include "priv-io.h"
 #include "util.h"
+#include "debug.h"
 
 
 /* The private event loops are used for all blocking operations, and
@@ -149,5 +150,17 @@ _gpgme_wait_on_condition (gpgme_ctx_t ct
 gpgme_error_t
 _gpgme_wait_one (gpgme_ctx_t ctx)
 {
-  return _gpgme_wait_on_condition (ctx, NULL);
+  gpgme_error_t err;
+
+  err = _gpgme_wait_on_condition (ctx, NULL);
+
+  /* Work around missing gpgme_release in kleopatra, which creates
+     dangling gpgsm processes.  */
+  if (ctx->engine)
+    {
+      _gpgme_engine_release (ctx->engine);
+      ctx->engine = NULL;
+    }
+
+  return err;
 }
