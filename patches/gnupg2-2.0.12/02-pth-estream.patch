#! /bin/sh
patch -p0 -f $* < $0
exit $?

2009-06-22  Werner Koch  <wk@g10code.com>

	* estream.c (es_pth_read, es_pth_write) [W32]: New.
	(ESTREAM_SYS_READ, ESTREAM_SYS_WRITE) [HAVE_PTH]: Use them.


Index: common/estream.c
===================================================================
--- common/estream.c	(revision 5047)
+++ common/estream.c	(working copy)
@@ -138,8 +138,8 @@
 /* Primitive system I/O.  */
 
 #ifdef HAVE_PTH
-# define ESTREAM_SYS_READ  pth_read
-# define ESTREAM_SYS_WRITE pth_write
+# define ESTREAM_SYS_READ  es_pth_read
+# define ESTREAM_SYS_WRITE es_pth_write
 #else
 # define ESTREAM_SYS_READ  read
 # define ESTREAM_SYS_WRITE write
@@ -325,8 +325,47 @@
   return ret;
 }
 
+
 
+/*
+ * I/O Helper
+ *
+ * Unfortunately our Pth emulation for Windows expects system handles
+ * for pth_read and pth_write.  We use a simple approach to fix this:
+ * If the function returns an error we fall back to a vanilla read or
+ * write, assuming that we do I/O on a plain file where the operation
+ * can't block.
+ */
+#ifdef HAVE_PTH
+static int
+es_pth_read (int fd, void *buffer, size_t size)
+{
+# ifdef HAVE_W32_SYSTEM
+  int rc = pth_read (fd, buffer, size);
+  if (rc == -1 && errno == EINVAL)
+    rc = read (fd, buffer, size);
+  return rc;
+# else /*!HAVE_W32_SYSTEM*/
+  return pth_read (fd, buffer, size);
+# endif /* !HAVE_W32_SYSTEM*/
+}
 
+static int
+es_pth_write (int fd, const void *buffer, size_t size)
+{
+# ifdef HAVE_W32_SYSTEM
+  int rc = pth_write (fd, buffer, size);
+  if (rc == -1 && errno == EINVAL)
+    rc = write (fd, buffer, size);
+  return rc;
+# else /*!HAVE_W32_SYSTEM*/
+  return pth_write (fd, buffer, size);
+# endif /* !HAVE_W32_SYSTEM*/
+}
+#endif /*HAVE_PTH*/
+
+
+
 /*
  * Initialization.
  */
