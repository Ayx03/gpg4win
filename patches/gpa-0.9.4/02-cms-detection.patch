#! /bin/sh
patch -p1 -l -f $* < $0
exit $?

From 3a8458ae7c083fd46e8d5e165997422a35bdd21f Mon Sep 17 00:00:00 2001
From: Werner Koch <wk@gnupg.org>
Date: Fri, 9 Aug 2013 19:46:10 +0200
Subject: [PATCH 1/2] Improve detection of CMS objects.

* configure.ac: Detect gpgme_data_identify.
* src/filetype.c (is_cms_data, is_cms_file): Use gpgme_data_identify
is available.
--

The gpgme_data_identify function has the advantage that it also
detects X.509 certificates.  This offers way to detect certificate
files and import them.  As of now the import function does only work
with PGP.
---
 configure.ac   |    9 +++++++++
 src/filetype.c |   54 +++++++++++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 62 insertions(+), 1 deletions(-)

diff --git a/configure.ac b/configure.ac
index 57d677f..9f5213d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -244,6 +244,15 @@ else
                 have_gpgme=yes,have_gpgme=no)
 fi

+_save_libs=$LIBS
+_save_cflags=$CFLAGS
+LIBS="$LIBS $GPGME_LIBS"
+CFLAGS="$CFLAGS $GPGME_CFLAGS"
+AC_CHECK_FUNCS([gpgme_data_identify])
+LIBS=$_save_libs
+CFLAGS="$_save_cflags"
+
+
 dnl The tests below are not anymore used because we now depend on a
 dnl gpgme which has all these features.  However, I keep the code here
 dnl for future work.
diff --git a/src/filetype.c b/src/filetype.c
index c59dde7..4e68d27 100644
--- a/src/filetype.c
+++ b/src/filetype.c
@@ -22,6 +22,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <gpgme.h>

 #include "parsetlv.h"
 #include "filetype.h"
@@ -32,6 +33,7 @@


 /* Warning: DATA may be binary but there must be a Nul before DATALEN.  */
+#ifndef HAVE_GPGME_DATA_IDENTIFY
 static int
 detect_cms (const char *data, size_t datalen)
 {
@@ -90,6 +92,7 @@ detect_cms (const char *data, size_t datalen)

   return 0;
 }
+#endif /*!HAVE_GPGME_DATA_IDENTIFY*/


 /* Return true if the file FNAME looks like an CMS file.  There is no
@@ -98,6 +101,34 @@ detect_cms (const char *data, size_t datalen)
 int
 is_cms_file (const char *fname)
 {
+#ifdef HAVE_GPGME_DATA_IDENTIFY
+  FILE *fp;
+  gpgme_data_t dh;
+  gpgme_data_type_t dt;
+
+  fp = fopen (fname, "rb");
+  if (!fp)
+    return 0; /* Not found - can't be a CMS file.  */
+  if (gpgme_data_new_from_stream (&dh, fp))
+    {
+      fclose (fp);
+      return 0;
+    }
+  dt = gpgme_data_identify (dh, 0);
+  gpgme_data_release (dh);
+  fclose (fp);
+  switch (dt)
+    {
+    case GPGME_DATA_TYPE_CMS_SIGNED:
+    case GPGME_DATA_TYPE_CMS_ENCRYPTED:
+    case GPGME_DATA_TYPE_CMS_OTHER:
+    case GPGME_DATA_TYPE_X509_CERT:
+    case GPGME_DATA_TYPE_PKCS12:
+      return 1;
+    default:
+      return 0;
+    }
+#else
   int result;
   FILE *fp;
   char *data;
@@ -121,6 +152,7 @@ is_cms_file (const char *fname)
   result = detect_cms (data, datalen);
   free (data);
   return result;
+#endif
 }


@@ -129,9 +161,28 @@ is_cms_file (const char *fname)
 int
 is_cms_data (const char *data, size_t datalen)
 {
+#ifdef HAVE_GPGME_DATA_IDENTIFY
+  gpgme_data_t dh;
+  gpgme_data_type_t dt;
+
+  if (gpgme_data_new_from_mem (&dh, data, datalen, 0))
+    return 0;
+  dt = gpgme_data_identify (dh, 0);
+  gpgme_data_release (dh);
+  switch (dt)
+    {
+    case GPGME_DATA_TYPE_CMS_SIGNED:
+    case GPGME_DATA_TYPE_CMS_ENCRYPTED:
+    case GPGME_DATA_TYPE_CMS_OTHER:
+    case GPGME_DATA_TYPE_X509_CERT:
+    case GPGME_DATA_TYPE_PKCS12:
+      return 1;
+    default:
+      return 0;
+    }
+#else
   int result;
   char *buffer;
-
   if (datalen < 24)
     return 0; /* Too short - don't bother to copy the buffer.  */

@@ -147,4 +198,5 @@ is_cms_data (const char *data, size_t datalen)
   result = detect_cms (buffer, datalen);
   free (buffer);
   return result;
+#endif
 }
--
1.7.7.1
