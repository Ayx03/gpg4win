#! /bin/sh
patch -p0 -f $* < $0
exit $?


2009-08-06  Werner Koch  <wk@g10code.com>

	* op-support.c (_gpgme_parse_inv_recp): Allow for no fingerprint.

	* engine-gpgsm.c (gpgsm_sign): Hook up the status func for the
	SIGNER command.
	* gpgme.h.in (GPGME_STATUS_INV_SGNR, GPGME_STATUS_NO_SGNR): New.
	* sign.c (op_data_t): Add fields IGNORE_INV_RECP and INV_SGNR_SEEN.
	(_gpgme_op_sign_init_result): Factor code out to ...
	(sign_init_result): .. new.  Init new fields.
	(sign_start): Use sign_init_result.
	(_gpgme_sign_status_handler): Take care of the new INV_SGNR.
	Return an error if no signature has been created.
 

Index: src/sign.c
===================================================================
--- src/sign.c	(revision 1393)
+++ src/sign.c	(working copy)
@@ -46,6 +46,10 @@
 
   /* Likewise for signature information.  */
   gpgme_new_signature_t *last_sig_p;
+
+  /* Flags used while processing the status lines.  */
+  unsigned int ignore_inv_recp:1;
+  unsigned int inv_sgnr_seen:1;
 } *op_data_t;
 
 
@@ -266,6 +270,12 @@
       break;
 
     case GPGME_STATUS_INV_RECP:
+      if (opd->inv_sgnr_seen && opd->ignore_inv_recp)
+        break; 
+      /* FALLTROUGH */
+    case GPGME_STATUS_INV_SGNR:
+      if (code == GPGME_STATUS_INV_SGNR)
+        opd->inv_sgnr_seen = 1;
       err = _gpgme_parse_inv_recp (args, opd->last_signer_p);
       if (err)
 	return err;
@@ -297,8 +307,8 @@
 }
 
 
-gpgme_error_t
-_gpgme_op_sign_init_result (gpgme_ctx_t ctx)
+static gpgme_error_t
+sign_init_result (gpgme_ctx_t ctx, int ignore_inv_recp)
 {
   gpgme_error_t err;
   void *hook;
@@ -311,10 +321,18 @@
     return err;
   opd->last_signer_p = &opd->result.invalid_signers;
   opd->last_sig_p = &opd->result.signatures;
+  opd->ignore_inv_recp = !!ignore_inv_recp;
+  opd->inv_sgnr_seen = 0;
   return 0;
 }
 
+gpgme_error_t
+_gpgme_op_sign_init_result (gpgme_ctx_t ctx)
+{
+  return sign_init_result (ctx, 0);
+}
 
+
 static gpgme_error_t
 sign_start (gpgme_ctx_t ctx, int synchronous, gpgme_data_t plain,
 	    gpgme_data_t sig, gpgme_sig_mode_t mode)
@@ -325,7 +343,10 @@
   if (err)
     return err;
 
-  err = _gpgme_op_sign_init_result (ctx);
+  /* If we are using the CMS protocol, we ignore the INV_RECP status
+     code if a newer GPGSM is in use.  GPGMS does not support combined
+     sign+encrypt and thus this can't harm.  */
+  err = sign_init_result (ctx, (ctx->protocol == GPGME_PROTOCOL_CMS));
   if (err)
     return err;
 
Index: src/gpgme.h.in
===================================================================
--- src/gpgme.h.in	(revision 1393)
+++ src/gpgme.h.in	(working copy)
@@ -485,7 +485,9 @@
     GPGME_STATUS_PKA_TRUST_BAD = 79,
     GPGME_STATUS_PKA_TRUST_GOOD = 80,
 
-    GPGME_STATUS_PLAINTEXT = 81
+    GPGME_STATUS_PLAINTEXT = 81,
+    GPGME_STATUS_INV_SGNR = 82,
+    GPGME_STATUS_NO_SGNR = 83
   }
 gpgme_status_code_t;
 
Index: src/engine-gpgsm.c
===================================================================
--- src/engine-gpgsm.c	(revision 1393)
+++ src/engine-gpgsm.c	(working copy)
@@ -1870,7 +1870,7 @@
       if (asprintf (&assuan_cmd, "OPTION include-certs %i", include_certs) < 0)
 	return gpg_error_from_errno (errno);
       err = gpgsm_assuan_simple_command (gpgsm->assuan_ctx, assuan_cmd,
-					 NULL, NULL);
+                                         NULL, NULL);
       free (assuan_cmd);
       if (err)
 	return err;
@@ -1885,7 +1885,8 @@
 
           strcpy (stpcpy (buf, "SIGNER "), s);
           err = gpgsm_assuan_simple_command (gpgsm->assuan_ctx, buf,
-                                             NULL, NULL);
+                                             gpgsm->status.fnc,
+                                             gpgsm->status.fnc_value);
 	}
       else
         err = gpg_error (GPG_ERR_INV_VALUE);
Index: src/op-support.c
===================================================================
--- src/op-support.c	(revision 1393)
+++ src/op-support.c	(working copy)
@@ -162,8 +162,8 @@
 }
 
 
-/* Parse the INV_RECP status line in ARGS and return the result in
-   KEY.  */
+/* Parse the INV_RECP or INV-SNDR status line in ARGS and return the
+   result in KEY.  */
 gpgme_error_t
 _gpgme_parse_inv_recp (char *args, gpgme_invalid_key_t *key)
 {
@@ -177,7 +177,7 @@
   inv_key->next = NULL;
   errno = 0;
   reason = strtol (args, &tail, 0);
-  if (errno || args == tail || *tail != ' ')
+  if (errno || args == tail || (*tail && *tail != ' '))
     {
       /* The crypto backend does not behave.  */
       free (inv_key);
@@ -236,7 +236,7 @@
       break;
     }
 
-  while (*tail == ' ')
+  while (*tail && *tail == ' ')
     tail++;
   if (*tail)
     {


Index: src/sign.c
===================================================================
--- src/sign.c	(revision 1394)
+++ src/sign.c	(working copy)
@@ -50,6 +50,7 @@
   /* Flags used while processing the status lines.  */
   unsigned int ignore_inv_recp:1;
   unsigned int inv_sgnr_seen:1;
+  unsigned int sig_created_seen:1;
 } *op_data_t;
 
 
@@ -262,6 +263,7 @@
   switch (code)
     {
     case GPGME_STATUS_SIG_CREATED:
+      opd->sig_created_seen = 1;
       err = parse_sig_created (args, opd->last_sig_p);
       if (err)
 	return err;
@@ -285,7 +287,9 @@
 
     case GPGME_STATUS_EOF:
       if (opd->result.invalid_signers)
-	return gpg_error (GPG_ERR_UNUSABLE_SECKEY);
+	err = gpg_error (GPG_ERR_UNUSABLE_SECKEY);
+      else if (!opd->sig_created_seen)
+	err = gpg_error (GPG_ERR_GENERAL);
       break;
 
     default:
@@ -323,6 +327,7 @@
   opd->last_sig_p = &opd->result.signatures;
   opd->ignore_inv_recp = !!ignore_inv_recp;
   opd->inv_sgnr_seen = 0;
+  opd->sig_created_seen = 0;
   return 0;
 }
 


