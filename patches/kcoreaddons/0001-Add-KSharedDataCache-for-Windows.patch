#! /bin/sh
patch -p1 -l -f $* < $0
exit $?

From 4e21e25e11c0639633d3bcc0b5a9dcd81591349c Mon Sep 17 00:00:00 2001
From: Andre Heinecke <aheinecke@gnupg.org>
Date: Thu, 4 May 2023 15:39:12 +0200
Subject: [PATCH] Add KSharedDataCache for Windows

It is a common pattern to map the mmap API to Windows API.
The copyright header in mmap_win_p.h clarifies where this code
was obtained. It was slightly modified by me to provide
everything the KSharedDataCache API needed.
---
 CMakeLists.txt                           |   4 +-
 src/lib/CMakeLists.txt                   |  18 +-
 src/lib/caching/kshareddatacache.cpp     |   3 +
 src/lib/caching/kshareddatacache_p.h     |   2 +
 src/lib/caching/kshareddatacache_win.cpp | 106 ------------
 src/lib/caching/mmap_win_p.h             | 204 +++++++++++++++++++++++
 6 files changed, 216 insertions(+), 121 deletions(-)
 delete mode 100644 src/lib/caching/kshareddatacache_win.cpp
 create mode 100644 src/lib/caching/mmap_win_p.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 934bf96e..9d2cabb8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -44,9 +44,7 @@ ecm_setup_qtplugin_macro_names(
         PACKAGE_SETUP_AUTOMOC_VARIABLES
 )

-if(NOT WIN32)
-    find_package(Threads REQUIRED)
-endif()
+find_package(Threads REQUIRED)

 # Configure checks for kdirwatch
 find_package(FAM)
diff --git a/src/lib/CMakeLists.txt b/src/lib/CMakeLists.txt
index 1f251c82..e1c865d5 100644
--- a/src/lib/CMakeLists.txt
+++ b/src/lib/CMakeLists.txt
@@ -47,21 +47,9 @@ if (Inotify_FOUND)
     target_link_libraries(KF5CoreAddons PRIVATE ${Inotify_LIBRARIES})
 endif ()

-if(NOT WIN32)
     target_sources(KF5CoreAddons PRIVATE
-        caching/kshareddatacache.cpp
-        caching/kshareddatacache.h
     )

-    set_source_files_properties(caching/kshareddatacache.cpp
-        PROPERTIES COMPILE_FLAGS -fexceptions)
-
-    target_link_libraries(KF5CoreAddons PRIVATE Threads::Threads)
-else()
-    target_sources(KF5CoreAddons PRIVATE
-        caching/kshareddatacache_win.cpp
-    )
-endif()

 if (WIN32)
     target_sources(KF5CoreAddons PRIVATE
@@ -112,6 +100,8 @@ endif()
 target_sources(KF5CoreAddons PRIVATE
     kaboutdata.cpp
     kcoreaddons.cpp
+    caching/kshareddatacache.cpp
+    caching/kshareddatacache.h
     io/kautosavefile.cpp
     io/kdirwatch.cpp
     io/kfilesystemtype.cpp
@@ -189,6 +179,8 @@ target_sources(KF5CoreAddons PRIVATE
     util/kruntimeplatform.h
 )

+set_source_files_properties(caching/kshareddatacache.cpp
+    PROPERTIES COMPILE_FLAGS -fexceptions)

 set(kcoreaddons_INCLUDE_DIRS
     ${CMAKE_CURRENT_BINARY_DIR}/../.. # for kcoreaddons_version.h
@@ -264,6 +256,8 @@ target_include_directories(KF5CoreAddons PUBLIC "$<BUILD_INTERFACE:${kcoreaddons
 target_link_libraries(KF5CoreAddons
   PUBLIC
     Qt${QT_MAJOR_VERSION}::Core
+  PRIVATE
+    Threads::Threads
 )

 if(WIN32)
diff --git a/src/lib/caching/kshareddatacache.cpp b/src/lib/caching/kshareddatacache.cpp
index 4f4ef8f1..2833f45a 100644
--- a/src/lib/caching/kshareddatacache.cpp
+++ b/src/lib/caching/kshareddatacache.cpp
@@ -25,7 +25,10 @@
 #include <QRandomGenerator>

 #include <stdlib.h>
+
+#ifndef Q_OS_WIN
 #include <sys/mman.h>
+#endif
 #include <sys/types.h>

 /// The maximum number of probes to make while searching for a bucket in
diff --git a/src/lib/caching/kshareddatacache_p.h b/src/lib/caching/kshareddatacache_p.h
index 1582b80d..9365d791 100644
--- a/src/lib/caching/kshareddatacache_p.h
+++ b/src/lib/caching/kshareddatacache_p.h
@@ -21,6 +21,8 @@
 #include <time.h>
 #include <unistd.h> // Check for sched_yield

+#include "mmap_win_p.h" // Windows mmap implementation
+
 // Mac OS X, for all its POSIX compliance, does not support timeouts on its
 // mutexes, which is kind of a disaster for cross-process support. However
 // synchronization primitives still work, they just might hang if the cache is
diff --git a/src/lib/caching/kshareddatacache_win.cpp b/src/lib/caching/kshareddatacache_win.cpp
deleted file mode 100644
index 3df004a6..00000000
--- a/src/lib/caching/kshareddatacache_win.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-    This file is part of the KDE project.
-
-    SPDX-FileCopyrightText: 2010 Michael Pyne <mpyne@kde.org>
-
-    SPDX-License-Identifier: LGPL-2.0-only
-*/
-
-/**
- * This is a horrifically simple implementation of KSharedDataCache that is
- * basically missing the "shared" part to it, for use on Windows or other platforms
- * that don't support POSIX.
- */
-#include "kshareddatacache.h"
-
-#include <QByteArray>
-#include <QCache>
-#include <QString>
-
-class Q_DECL_HIDDEN KSharedDataCache::Private
-{
-public:
-    KSharedDataCache::EvictionPolicy evictionPolicy;
-    QCache<QString, QByteArray> cache;
-};
-
-KSharedDataCache::KSharedDataCache(const QString &cacheName, unsigned defaultCacheSize, unsigned expectedItemSize)
-    : d(new Private)
-{
-    d->cache.setMaxCost(defaultCacheSize);
-
-    Q_UNUSED(cacheName);
-    Q_UNUSED(expectedItemSize);
-}
-
-KSharedDataCache::~KSharedDataCache()
-{
-    delete d;
-}
-
-KSharedDataCache::EvictionPolicy KSharedDataCache::evictionPolicy() const
-{
-    return d->evictionPolicy;
-}
-
-void KSharedDataCache::setEvictionPolicy(KSharedDataCache::EvictionPolicy newPolicy)
-{
-    d->evictionPolicy = newPolicy;
-}
-
-bool KSharedDataCache::insert(const QString &key, const QByteArray &data)
-{
-    return d->cache.insert(key, new QByteArray(data));
-}
-
-bool KSharedDataCache::find(const QString &key, QByteArray *destination) const
-{
-    QByteArray *value = d->cache.object(key);
-
-    if (value) {
-        if (destination) {
-            *destination = *value;
-        }
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void KSharedDataCache::clear()
-{
-    d->cache.clear();
-}
-
-void KSharedDataCache::deleteCache(const QString &cacheName)
-{
-    Q_UNUSED(cacheName);
-}
-
-bool KSharedDataCache::contains(const QString &key) const
-{
-    return d->cache.contains(key);
-}
-
-unsigned KSharedDataCache::totalSize() const
-{
-    return static_cast<unsigned>(d->cache.maxCost());
-}
-
-unsigned KSharedDataCache::freeSize() const
-{
-    if (d->cache.totalCost() < d->cache.maxCost()) {
-        return static_cast<unsigned>(d->cache.maxCost() - d->cache.totalCost());
-    } else {
-        return 0;
-    }
-}
-
-unsigned KSharedDataCache::timestamp() const
-{
-    return 0;
-}
-
-void KSharedDataCache::setTimestamp(unsigned newTimestamp)
-{
-}
diff --git a/src/lib/caching/mmap_win_p.h b/src/lib/caching/mmap_win_p.h
new file mode 100644
index 00000000..9f805ce0
--- /dev/null
+++ b/src/lib/caching/mmap_win_p.h
@@ -0,0 +1,204 @@
+/*
+    This file is part of the KDE project.
+
+    SPDX-FileCopyrightText: 2014 Newcastle University, UK. <openlab@ncl.ac.uk>
+    SPDX-FileCopyrightText: 2023 g10 Code GmbH
+
+    SPDX-License-Identifier: BSD-2-Clause
+
+    This code was copied from the openmovement repository under the BSD-2-Clause
+    license. In revision 8f168811b2e68788776ee026d7809d498c47c6c3
+    See: https://github.com/digitalinteraction/openmovement
+*/
+
+/*
+ * Copyright (c) 2014, Newcastle University, UK.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+// Memory mapped file - Implementation of mmap() for Windows for use with KSharedDataCache
+// this is not a full mmap implementation but covers the usage of KSharedDataCache.
+// Andre Heinecke, 2023
+// - Add QT_MMAP macro for easier integration with KSharedDatacache
+// - Always use MMAP_CLEANUP code
+// - Add sysconf(_SC_SEMAPHORES)
+// - Add sysconf(_SC_TIMEOUTS)
+// Dan Jackson, 2014
+// - 'MMAP_CLEANUP' changes to clean up otherwise leaked handles from CreateFileMapping()
+// - 'sysconf(_SC_PAGE_SIZE)' implementation
+// Original author: Mike Frysinger <vapier@gentoo.org>, placed into the public domain.
+
+// References:
+//   CreateFileMapping: http://msdn.microsoft.com/en-us/library/aa366537(VS.85).aspx
+//   CloseHandle:       http://msdn.microsoft.com/en-us/library/ms724211(VS.85).aspx
+//   MapViewOfFile:     http://msdn.microsoft.com/en-us/library/aa366761(VS.85).aspx
+//   UnmapViewOfFile:   http://msdn.microsoft.com/en-us/library/aa366882(VS.85).aspx
+
+// This file does nothing if not on Windows
+#ifdef _WIN32
+#ifndef MMAP_WIN32_P_H // Designed to be included for local static versions
+#define MMAP_WIN32_P_H
+
+#ifndef QT_MMAP
+#define QT_MMAP mmap
+#endif
+
+#include <io.h>
+#include <sys/types.h>
+#include <windows.h>
+
+struct mmap_cleanup_tag;
+typedef struct mmap_cleanup_tag {
+    void *addr;
+    HANDLE h;
+    struct mmap_cleanup_tag *next;
+} mmap_cleanup_t;
+static mmap_cleanup_t *mmap_cleanup = NULL;
+
+#define PROT_READ 0x1
+#define PROT_WRITE 0x2
+#define PROT_EXEC 0x4
+
+#define MAP_SHARED 0x01
+#define MAP_PRIVATE 0x02
+#define MAP_ANONYMOUS 0x20
+#define MAP_ANON MAP_ANONYMOUS
+#define MAP_FAILED ((void *)-1)
+
+#ifdef __USE_FILE_OFFSET64
+#define MM_DWORD_HI(x) (x >> 32)
+#define MM_DWORD_LO(x) ((x)&0xffffffff)
+#else
+#define MM_DWORD_HI(x) (0)
+#define MM_DWORD_LO(x) (x)
+#endif
+
+static void *mmap(void *, size_t length, int prot, int flags, int fd, off_t offset)
+{
+    if (prot & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
+        return MAP_FAILED;
+    if (fd == -1) {
+        if (!(flags & MAP_ANON) || offset)
+            return MAP_FAILED;
+    } else if (flags & MAP_ANON)
+        return MAP_FAILED;
+
+    DWORD flProtect;
+    if (prot & PROT_WRITE) {
+        if (prot & PROT_EXEC)
+            flProtect = PAGE_EXECUTE_READWRITE;
+        else
+            flProtect = PAGE_READWRITE;
+    } else if (prot & PROT_EXEC) {
+        if (prot & PROT_READ)
+            flProtect = PAGE_EXECUTE_READ;
+        else if (prot & PROT_EXEC)
+            flProtect = PAGE_EXECUTE;
+    } else
+        flProtect = PAGE_READONLY;
+
+    off_t end = (off_t)(length + offset);
+    HANDLE mmap_fd, h;
+    if (fd == -1)
+        mmap_fd = INVALID_HANDLE_VALUE;
+    else
+        mmap_fd = (HANDLE)_get_osfhandle(fd);
+    h = CreateFileMapping(mmap_fd, NULL, flProtect, MM_DWORD_HI(end), MM_DWORD_LO(end), NULL);
+    if (h == NULL)
+        return MAP_FAILED;
+
+    DWORD dwDesiredAccess;
+    if (prot & PROT_WRITE)
+        dwDesiredAccess = FILE_MAP_WRITE;
+    else
+        dwDesiredAccess = FILE_MAP_READ;
+    if (prot & PROT_EXEC)
+        dwDesiredAccess |= FILE_MAP_EXECUTE;
+    if (flags & MAP_PRIVATE)
+        dwDesiredAccess |= FILE_MAP_COPY;
+    void *ret = MapViewOfFile(h, dwDesiredAccess, MM_DWORD_HI(offset), MM_DWORD_LO(offset), length);
+    if (ret == NULL) {
+        CloseHandle(h);
+        ret = MAP_FAILED;
+    } else {
+        // Add a tracking element (to the start of our list)
+        mmap_cleanup_t *mc = (mmap_cleanup_t *)malloc(sizeof(mmap_cleanup_t));
+        if (mc != NULL) {
+            mc->addr = ret;
+            mc->h = h;
+            mc->next = mmap_cleanup;
+            mmap_cleanup = mc;
+        }
+    }
+    return ret;
+}
+
+static int munmap(void *addr, size_t)
+{
+    UnmapViewOfFile(addr);
+    // Look up through the tracking elements to close the handle
+    mmap_cleanup_t **prevPtr = &mmap_cleanup;
+    mmap_cleanup_t *mc;
+    for (mc = *prevPtr; mc != NULL; prevPtr = &mc->next, mc = *prevPtr) {
+        if (mc->addr == addr) {
+            CloseHandle(mc->h);
+            *prevPtr = mc->next;
+            break;
+        }
+    }
+    return 0;
+}
+
+#define _SC_PAGE_SIZE 1
+#define _SC_NPROCESSORS_CONF 2
+#define _SC_NPROCESSORS_ONLN 3
+#define _SC_SEMAPHORES 4
+#define _SC_TIMEOUTS 5
+#define getpagesize() sysconf(_SC_PAGE_SIZE)
+#define get_nprocs_conf() sysconf(_SC_NPROCESSORS_CONF)
+#define get_nprocs() sysconf(_SC_NPROCESSORS_ONLN)
+static long sysconf(int name)
+{
+    switch (name) {
+    case _SC_PAGE_SIZE: {
+        SYSTEM_INFO systemInfo;
+        GetSystemInfo(&systemInfo);
+        return systemInfo.dwAllocationGranularity; // NOT systemInfo.dwPageSize;
+    }
+    case _SC_NPROCESSORS_CONF:
+    case _SC_NPROCESSORS_ONLN: {
+        SYSTEM_INFO systemInfo;
+        GetSystemInfo(&systemInfo);
+        return systemInfo.dwNumberOfProcessors;
+    }
+    case _SC_SEMAPHORES:
+        return _POSIX_SEMAPHORES;
+    case _SC_TIMEOUTS:
+        return _POSIX_TIMEOUTS;
+    default:
+        return -1;
+    }
+}
+
+#endif // MMAP_WIN32_C
+#endif // _WIN32
--
2.40.1
