#! /bin/sh
patch -p0 -f $* < $0
exit $?


2008-04-01  Werner Koch  <wk@g10code.com>

	* keybox-init.c (keybox_new, keybox_release): Track used handles.
	(_keybox_close_file): New.
	* keybox-update.c (keybox_insert_cert, keybox_set_flags) 
	(keybox_delete, keybox_compress): Use the new close function.




Index: kbx/keybox-init.c
===================================================================
--- kbx/keybox-init.c	(revision 4720)
+++ kbx/keybox-init.c	(working copy)
@@ -30,10 +30,9 @@
 static KB_NAME kb_names;
 
 
-/* 
-  Register a filename for plain keybox files.  Returns a pointer to be
-  used to create a handles etc or NULL to indicate that it has already
-  been registered */
+/* Register a filename for plain keybox files.  Returns a pointer to
+   be used to create a handles and so on.  Returns NULL to indicate
+   that FNAME has already been registered.  */
 void *
 keybox_register_file (const char *fname, int secret)
 {
@@ -50,6 +49,10 @@
     return NULL;
   strcpy (kr->fname, fname);
   kr->secret = !!secret;
+
+  kr->handle_table = NULL;
+  kr->handle_table_size = 0;
+
   /* kr->lockhd = NULL;*/
   kr->is_locked = 0;
   kr->did_full_scan = 0;
@@ -83,6 +86,7 @@
 {
   KEYBOX_HANDLE hd;
   KB_NAME resource = token;
+  int idx;
 
   assert (resource && !resource->secret == !secret);
   hd = xtrycalloc (1, sizeof *hd);
@@ -90,6 +94,43 @@
     {
       hd->kb = resource;
       hd->secret = !!secret;
+      if (!resource->handle_table)
+        {
+          resource->handle_table_size = 3;
+          resource->handle_table = xtrycalloc (resource->handle_table_size,
+                                               sizeof *resource->handle_table);
+          if (!resource->handle_table)
+            {
+              resource->handle_table_size = 0;
+              xfree (hd);
+              return NULL;
+            }
+        }
+      for (idx=0; idx < resource->handle_table_size; idx++)
+        if (!resource->handle_table[idx])
+          {
+            resource->handle_table[idx] = hd;
+            break;
+          }
+      if (!(idx < resource->handle_table_size))
+        {
+          KEYBOX_HANDLE *tmptbl;
+          size_t newsize;
+
+          newsize = resource->handle_table_size + 5;
+          tmptbl = xtryrealloc (resource->handle_table, 
+                                newsize * sizeof (*tmptbl));
+          if (!tmptbl)
+            {
+              xfree (hd);
+              return NULL;
+            }
+          resource->handle_table = tmptbl;
+          resource->handle_table_size = newsize;
+          resource->handle_table[idx] = hd;
+          for (idx++; idx < resource->handle_table_size; idx++)
+            resource->handle_table[idx] = NULL;
+        }
     }
   return hd;
 }
@@ -99,6 +140,13 @@
 {
   if (!hd)
     return;
+  if (hd->kb->handle_table)
+    {
+      int idx;
+      for (idx=0; idx < hd->kb->handle_table_size; idx++)
+        if (hd->kb->handle_table[idx] == hd)
+          hd->kb->handle_table[idx] = NULL;
+    }
   _keybox_release_blob (hd->found.blob);
   if (hd->fp)
     {
@@ -128,3 +176,27 @@
   return 0;
 }
 
+
+/* Close the file of the resource identified by HD.  For consistent
+   results this fucntion closes the files of all handles pointing to
+   the resource identified by HD.  */
+void 
+_keybox_close_file (KEYBOX_HANDLE hd)
+{
+  int idx;
+  KEYBOX_HANDLE roverhd;
+
+  if (!hd || !hd->kb || !hd->kb->handle_table)
+    return;
+
+  for (idx=0; idx < hd->kb->handle_table_size; idx++)
+    if ((roverhd = hd->kb->handle_table[idx]))
+      {
+        if (roverhd->fp)
+          {
+            fclose (roverhd->fp);
+            roverhd->fp = NULL;
+          }
+      }
+  assert (!hd->fp);
+}
Index: kbx/keybox-search.c
===================================================================
--- kbx/keybox-search.c	(revision 4720)
+++ kbx/keybox-search.c	(working copy)
@@ -458,7 +458,7 @@
 #ifdef KEYBOX_WITH_X509
 /* Return true if the key in BLOB matches the 20 bytes keygrip GRIP.
    We don't have the keygrips as meta data, thus wen need to parse the
-   certificate. Fixme: We might wat to return proper error codes
+   certificate. Fixme: We might want to return proper error codes
    instead of failing a search for invalid certificates etc.  */
 static int
 blob_x509_has_grip (KEYBOXBLOB blob, const unsigned char *grip)
@@ -750,10 +750,10 @@
         }
     }
 
-  /* kludge: we need to convert an SN given as hexstring to it's
-     binary representation - in some cases we are not able to store it
-     in the search descriptor, because due to its usage it is not
-     possible to free allocated memory */
+  /* Kludge: We need to convert an SN given as hexstring to its binary
+     representation - in some cases we are not able to store it in the
+     search descriptor, because due to the way we use it, it is not
+     possible to free allocated memory. */
   if (sn_array)
     {
       const unsigned char *s;
Index: kbx/keybox-update.c
===================================================================
--- kbx/keybox-update.c	(revision 4720)
+++ kbx/keybox-update.c	(working copy)
@@ -136,7 +136,7 @@
       xfree (bakfname);
       return tmperr;
     }
-  
+
   *r_bakfname = bakfname;
   *r_tmpfname = tmpfname;
   return 0;
@@ -167,7 +167,7 @@
 /*    iobuf_ioctl (NULL, 2, 0, (char*)bakfname ); */
 /*    iobuf_ioctl (NULL, 2, 0, (char*)fname ); */
 
-  /* first make a backup file except for secret keyboxs */
+  /* First make a backup file except for secret keyboxes. */
   if (!secret)
     { 
 #if defined(HAVE_DOSISH_SYSTEM) || defined(__riscos__)
@@ -179,7 +179,7 @@
 	}
     }
   
-  /* then rename the file */
+  /* Then rename the file. */
 #if defined(HAVE_DOSISH_SYSTEM) || defined(__riscos__)
   remove (fname);
 #endif
@@ -386,12 +386,8 @@
 
   /* Close this one otherwise we will mess up the position for a next
      search.  Fixme: it would be better to adjust the position after
-     the write opertions.  */
-  if (hd->fp)
-    {
-      fclose (hd->fp);
-      hd->fp = NULL;
-    }
+     the write operation.  */
+  _keybox_close_file (hd);
 
   rc = _keybox_create_x509_blob (&blob, cert, sha1_digest, hd->ephemeral);
   if (!rc)
@@ -453,11 +449,7 @@
   
   off += flag_pos;
 
-  if (hd->fp)
-    {
-      fclose (hd->fp);
-      hd->fp = NULL;
-    }
+  _keybox_close_file (hd);
   fp = fopen (hd->kb->fname, "r+b");
   if (!fp)
     return gpg_error (gpg_err_code_from_errno (errno));
@@ -522,12 +514,7 @@
     return gpg_error (GPG_ERR_GENERAL);
   off += 4;
 
-  if (hd->fp)
-    {
-      fclose (hd->fp);
-      hd->fp = NULL;
-    }
-  
+  _keybox_close_file (hd);
   fp = fopen (hd->kb->fname, "r+b");
   if (!fp)
     return gpg_error (gpg_err_code_from_errno (errno));
@@ -575,11 +562,7 @@
   if (!fname)
     return gpg_error (GPG_ERR_INV_HANDLE); 
 
-  if (hd->fp)
-    {
-      fclose (hd->fp);
-      hd->fp = NULL;
-    }
+  _keybox_close_file (hd);
 
   /* Open the source file. Because we do a rename, we have to check the 
      permissions of the file */
Index: kbx/keybox-defs.h
===================================================================
--- kbx/keybox-defs.h	(revision 4720)
+++ kbx/keybox-defs.h	(working copy)
@@ -53,13 +53,31 @@
 
 
 typedef struct keybox_name *KB_NAME;
-typedef struct keybox_name const * CONST_KB_NAME;
-struct keybox_name {
-  struct keybox_name *next;
+typedef struct keybox_name const *CONST_KB_NAME;
+struct keybox_name 
+{
+  /* Link to the next resources, so that we can walk all
+     resources.  */
+  KB_NAME next;
+
+  /* True if this is a keybox with secret keys.  */
   int secret;
+
   /*DOTLOCK lockhd;*/
+
+  /* A table with all the handles accessing this resources.
+     HANDLE_TABLE_SIZE gives the allocated length of this table unused
+     entrues are set to NULL.  HANDLE_TABLE may be NULL. */
+  KEYBOX_HANDLE *handle_table;
+  size_t handle_table_size;
+  
+  /* Not yet used.  */
   int is_locked;
+
+  /* Not yet used.  */
   int did_full_scan;
+
+  /* The name of the resource file. */
   char fname[1];
 };
 
@@ -129,7 +147,10 @@
 /*    int preserve_permissions; */
 /*  } keybox_opt; */
 
+/*-- keybox-init.c --*/
+void _keybox_close_file (KEYBOX_HANDLE hd);
 
+
 /*-- keybox-blob.c --*/
 #ifdef KEYBOX_WITH_OPENPGP
   /* fixme */




