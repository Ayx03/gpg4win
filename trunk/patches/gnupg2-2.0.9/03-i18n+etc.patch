#! /bin/sh
patch -p1 -f $* < $0
exit $?




--- gnupg-2.0.9/jnlib/w32-gettext.c	2008-03-25 20:12:57.000000000 +0100
+++ jnlib/w32-gettext.c	2008-04-08 15:16:29.000000000 +0200
@@ -96,11 +96,13 @@
 struct loaded_domain
 {
   char *data;
+  char *data_native; /* Data mapped to the native version of the
+                        string.  (Allocated along with DATA). */
   int must_swap;
   u32 nstrings;
-  char *mapped;  /* 0 = not yet mapped, 1 = mapped,
-                    2 = mapped to
-                    overflow space */
+  char *mapped;  /* 0 = not mapped (original utf8), 
+                    1 = mapped to native encoding,
+                    2 = mapped to native encoding in overflow space.   */
   struct overflow_space_s *overflow_space;
   struct string_desc *orig_tab;
   struct string_desc *trans_tab;
@@ -111,6 +113,8 @@
 
 static struct loaded_domain *the_domain;
 static char *the_langid;
+static int want_utf8;  /* True if the user want's utf-8 strings.  */
+
 
 static __inline__ u32
 do_swap_u32( u32 i )
@@ -1236,7 +1240,7 @@
       return NULL;
     }
 
-  data = jnlib_malloc (size);
+  data = (2*size <= size)? NULL : jnlib_malloc (2*size);
   if (!data)
     {
       fclose (fp);
@@ -1278,38 +1282,39 @@
       return NULL;
     }
   domain->data = (char *) data;
+  domain->data_native = (char *) data + size;
   domain->must_swap = data->magic != MAGIC;
 
   /* Fill in the information about the available tables.  */
-    switch (SWAPIT(domain->must_swap, data->revision))
-      {
-      case 0:
-	domain->nstrings = SWAPIT(domain->must_swap, data->nstrings);
-	domain->orig_tab = (struct string_desc *)
+  switch (SWAPIT(domain->must_swap, data->revision))
+    {
+    case 0:
+      domain->nstrings = SWAPIT(domain->must_swap, data->nstrings);
+      domain->orig_tab = (struct string_desc *)
 	  ((char *) data + SWAPIT(domain->must_swap, data->orig_tab_offset));
-	domain->trans_tab = (struct string_desc *)
-	  ((char *) data + SWAPIT(domain->must_swap, data->trans_tab_offset));
-	domain->hash_size = SWAPIT(domain->must_swap, data->hash_tab_size);
-	domain->hash_tab = (u32 *)
-	  ((char *) data + SWAPIT(domain->must_swap, data->hash_tab_offset));
-        break;
+      domain->trans_tab = (struct string_desc *)
+        ((char *) data + SWAPIT(domain->must_swap, data->trans_tab_offset));
+      domain->hash_size = SWAPIT(domain->must_swap, data->hash_tab_size);
+      domain->hash_tab = (u32 *)
+        ((char *) data + SWAPIT(domain->must_swap, data->hash_tab_offset));
+      break;
         
-      default: /* This is an invalid revision.	*/
-	jnlib_free( data );
-	jnlib_free( domain );
-	return NULL;
+    default: /* This is an invalid revision.	*/
+      jnlib_free( data );
+      jnlib_free( domain );
+      return NULL;
     }
-
-    /* Allocate an array to keep track of code page mappings. */
-    domain->mapped = jnlib_calloc (1, domain->nstrings);
-    if (!domain->mapped)
-      {
-        jnlib_free (data);
-        jnlib_free (domain);
-        return NULL;
-      }
-
-    return domain;
+  
+  /* Allocate an array to keep track of code page mappings. */
+  domain->mapped = jnlib_calloc (1, domain->nstrings);
+  if (!domain->mapped)
+    {
+      jnlib_free (data);
+      jnlib_free (domain);
+      return NULL;
+    }
+  
+  return domain;
 }
 
 
@@ -1510,30 +1515,45 @@
 
 
 static const char*
-get_string( struct loaded_domain *domain, u32 idx )
+get_string (struct loaded_domain *domain, u32 idx)
 {
   struct overflow_space_s *os;
   char *p;
 
-  p = domain->data + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset);
-  if (!domain->mapped[idx]) 
+  if (want_utf8)
+    {
+      p = (domain->data 
+           + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset));
+    }
+  else if (!domain->mapped[idx]) 
     {
+      /* Not yet mapped - map utf-8 to native encoding.  */
+      const char *p_orig;
       size_t plen, buflen;
       char *buf;
 
-      domain->mapped[idx] = 1;
+      p_orig = (domain->data 
+                + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset));
+      p = (domain->data_native 
+           + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset));
 
-      plen = strlen (p);
-      buf = utf8_to_native (p, plen, -1);
+      plen = strlen (p_orig);
+      buf = utf8_to_native (p_orig, plen, -1);
       buflen = strlen (buf);
       if (buflen <= plen)
-        strcpy (p, buf);
+        {
+          /* Copy into the DATA_NATIVE area. */
+          strcpy (p, buf);
+          domain->mapped[idx] = 1;
+        }
       else
         {
           /* There is not enough space for the translation - store it
-             in the overflow_space else and mark that in the mapped
-             array.  Because we expect that this won't happen too
-             often, we use a simple linked list.  */
+             in the overflow_space and mark that in the mapped array.
+             Because UTF-8 strings are in general longer than the
+             Windows 2 byte encodings, we expect that this won't
+             happen too often (if at all) and thus we use a linked
+             list to manage this space. */
           os = jnlib_malloc (sizeof *os + buflen);
           if (os)
             {
@@ -1545,9 +1565,16 @@
             }
           else
             p = "ERROR in GETTEXT MALLOC";
+          domain->mapped[idx] = 2;
         }
       jnlib_free (buf);
     }
+  else if (domain->mapped[idx] == 1) 
+    {
+      p = (domain->data_native
+           + SWAPIT(domain->must_swap, domain->trans_tab[idx].offset));
+
+    }
   else if (domain->mapped[idx] == 2) 
     { /* We need to get the string from the overflow_space. */
       for (os=domain->overflow_space; os; os = os->next)
@@ -1555,6 +1582,9 @@
           return (const char*)os->d;
       p = "ERROR in GETTEXT\n";
     }
+  else
+    p = "ERROR in GETEXT mapping";
+
   return (const char*)p;
 }
 
@@ -1660,5 +1690,12 @@
 }
 
 
+void
+gettext_select_utf8 (int value)
+{
+  want_utf8 = value;
+}
+
+
 #endif /* USE_SIMPLE_GETTEXT */


--- gnupg-2.0.9/jnlib/w32help.h	2008-03-25 19:38:22.000000000 +0100
+++ jnlib/w32help.h	2008-04-08 15:16:54.000000000 +0200
@@ -33,7 +33,8 @@
 const char *ngettext (const char *msgid1, const char *msgid2,
                       unsigned long int n);
 const char *gettext_localename (void);
+void gettext_select_utf8 (int value);
 #endif /*USE_SIMPLE_GETTEXT*/
 
 


--- gnupg-2.0.9/common/i18n.c	2007-12-04 14:15:10.000000000 +0100
+++ common/i18n.c	2008-04-08 15:31:20.000000000 +0200
@@ -45,17 +45,19 @@
 
 
 /* The Assuan agent protocol requires us to transmit utf-8 strings
-   thus we need a fuctnion to temporary switch gettext from native to
+   thus we need a way to temporary switch gettext from native to
    utf8.  */
 char *
 i18n_switchto_utf8 (void)
 {
-#ifdef ENABLE_NLS
+#ifdef USE_SIMPLE_GETTEXT
+  gettext_select_utf8 (1);
+#elif define(ENABLE_NLS)
   char *orig_codeset = bind_textdomain_codeset (PACKAGE_GT, NULL);
-#ifdef HAVE_LANGINFO_CODESET
+# ifdef HAVE_LANGINFO_CODESET
   if (!orig_codeset)
     orig_codeset = nl_langinfo (CODESET);
-#endif
+# endif
   if (orig_codeset)
     { /* We only switch when we are able to restore the codeset later.
          Note that bind_textdomain_codeset does only return on memory
@@ -78,8 +80,10 @@
 void
 i18n_switchback (char *saved_codeset)
 {
-#ifdef ENABLE_NLS
+#ifdef USE_SIMPLE_GETTEXT
+  gettext_select_utf8 (0);
+#elif defined(ENABLE_NLS)
   if (saved_codeset)
     {
       bind_textdomain_codeset (PACKAGE_GT, saved_codeset);


--- gnupg-2.0.9/g10/gpg.c	2008-03-17 17:59:54.000000000 +0100
+++ g10/gpg.c	2008-04-08 16:11:03.000000000 +0200
@@ -704,6 +704,7 @@
        I'm returning the favor. */
     { oLocalUser, "sign-with", 2, "@" },
     { oRecipient, "user", 2, "@" },
+
     { oRequireCrossCert, "require-backsigs", 0, "@"},
     { oRequireCrossCert, "require-cross-certification", 0, "@"},
     { oNoRequireCrossCert, "no-require-backsigs", 0, "@"},
@@ -1549,6 +1550,11 @@
   printf ("reader-port:%lu:\n", GC_OPT_FLAG_NONE);
   printf ("default-key:%lu:\n", GC_OPT_FLAG_NONE);
   printf ("encrypt-to:%lu:\n", GC_OPT_FLAG_NONE);
+  printf ("auto-key-locate:%lu:\n", GC_OPT_FLAG_NONE);
+  printf ("allow-pka-lookup:%lu:\n", GC_OPT_FLAG_NONE);
+  printf ("log-file:%lu:\n", GC_OPT_FLAG_NONE);
+  printf ("debug-level:%lu:\"none:\n", GC_OPT_FLAG_DEFAULT);
+
 
   xfree (configfile_esc);
 }
@@ -2932,6 +2938,15 @@
               "use!\n");
 #endif
 
+    /* Older Libgcrypts fail with an assertion during DSA key
+       generation.  Better disable DSA2 entirely. */
+    if (opt.flags.dsa2 && !gcry_check_version ("1.4.0") )
+      {
+        log_info ("WARNING: "
+                  "DSA2 is only available with Libgcrypt 1.4 and later\n");
+        opt.flags.dsa2 = 0;
+      }
+
     if (opt.verbose > 2)
         log_info ("using character set `%s'\n", get_native_charset ());
 

