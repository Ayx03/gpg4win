#! /bin/sh
patch -p1 -f $* < $0
exit $?

Implement write support for fd I/O channels in glib on W32 targets.

(no changelog yet)

diff -ru glib/giowin32.c glib-2.6.6/glib/giowin32.c
--- glib/giowin32.c	2005-03-30 14:02:48.000000000 +0200
+++ glib/giowin32.c	2005-12-31 04:37:17.000000000 +0100
@@ -95,7 +95,8 @@
   gushort revents;
 
   /* Following fields used by fd channels for input */
-  
+  int direction;
+
   /* Data is kept in a circular buffer. To be able to distinguish between
    * empty and full buffer, we cannot fill it completely, but have to
    * leave a one character gap.
@@ -215,6 +216,7 @@
     }
 }
 
+
 static unsigned __stdcall
 read_thread (void *parameter)
 {
@@ -231,6 +233,7 @@
 	     (guint) channel->data_avail_event,
 	     (guint) channel->space_avail_event);
   
+  channel->direction = 0;
   channel->buffer = g_malloc (BUFFER_SIZE);
   channel->rdp = channel->wrp = 0;
   channel->running = TRUE;
@@ -276,7 +279,12 @@
       UNLOCK (channel->mutex);
 
       nbytes = read (channel->fd, buffer, nbytes);
-      
+      //      {
+      //	DWORD nb;
+      //	ReadFile (_get_osfhandle (channel->fd), buffer, nbytes, &nb, NULL);
+      //	nbytes = nb;
+      //      }
+
       LOCK (channel->mutex);
 
       channel->revents = G_IO_IN;
@@ -325,6 +333,121 @@
   return 0;
 }
 
+
+static unsigned __stdcall
+write_thread (void *parameter)
+{
+  GIOWin32Channel *channel = parameter;
+  guchar *buffer;
+  guint nbytes;
+
+  g_io_channel_ref ((GIOChannel *)channel);
+
+  if (channel->debug)
+    g_print ("write_thread %#x: start fd:%d, data_avail:%#x space_avail:%#x\n",
+	     channel->thread_id,
+	     channel->fd,
+	     (guint) channel->data_avail_event,
+	     (guint) channel->space_avail_event);
+  
+  channel->direction = 1;
+  channel->buffer = g_malloc (BUFFER_SIZE);
+  channel->rdp = channel->wrp = 0;
+  channel->running = TRUE;
+
+  SetEvent (channel->space_avail_event);
+  
+  LOCK (channel->mutex);
+  while (channel->running)
+    {
+      if (channel->debug)
+	g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
+		 channel->thread_id, channel->rdp, channel->wrp);
+      if (channel->wrp == channel->rdp)
+	{
+	  /* Buffer is empty.  */
+	  if (channel->debug)
+	    g_print ("write_thread %#x: resetting space_avail\n",
+		     channel->thread_id);
+	  ResetEvent (channel->space_avail_event);
+	  if (channel->debug)
+	    g_print ("write_thread %#x: waiting for data\n",
+		     channel->thread_id);
+	  channel->revents = G_IO_OUT;
+	  SetEvent (channel->data_avail_event);
+	  UNLOCK (channel->mutex);
+	  WaitForSingleObject (channel->space_avail_event, INFINITE);
+
+	  LOCK (channel->mutex);
+	  if (channel->debug)
+	    g_print ("write_thread %#x: rdp=%d, wrp=%d\n",
+		     channel->thread_id, channel->rdp, channel->wrp);
+	}
+      
+      buffer = channel->buffer + channel->rdp;
+      if (channel->rdp < channel->wrp)
+	nbytes = channel->wrp - channel->rdp;
+      else
+	nbytes = BUFFER_SIZE - channel->rdp;
+
+      if (channel->debug)
+	g_print ("write_thread %#x: calling write() for %d bytes\n",
+		 channel->thread_id, nbytes);
+
+      UNLOCK (channel->mutex);
+      nbytes = write (channel->fd, buffer, nbytes);
+      //      {
+      //	DWORD nb;
+      //	WriteFile (_get_osfhandle (channel->fd), buffer, nbytes, &nb, NULL);
+      //	nbytes = nb;
+      //      }
+
+      LOCK (channel->mutex);
+
+      if (channel->debug)
+	g_print ("write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n",
+		 channel->thread_id, channel->fd, nbytes, channel->rdp, channel->wrp);
+
+      channel->revents = 0;
+      if (nbytes > 0)
+	channel->revents |= G_IO_OUT;
+      else if (nbytes <= 0)
+	channel->revents |= G_IO_ERR;
+
+      channel->rdp = (channel->rdp + nbytes) % BUFFER_SIZE;
+
+      if (nbytes <= 0)
+	break;
+
+      if (channel->debug)
+	g_print ("write_thread: setting data_avail for thread %#x\n",
+		 channel->thread_id);
+      SetEvent (channel->data_avail_event);
+    }
+  
+  channel->running = FALSE;
+  if (channel->needs_close)
+    {
+      if (channel->debug)
+	g_print ("write_thread %#x: channel fd %d needs closing\n",
+		 channel->thread_id, channel->fd);
+      close (channel->fd);
+      channel->fd = -1;
+    }
+
+  UNLOCK (channel->mutex);
+  
+  g_io_channel_unref ((GIOChannel *)channel);
+  
+  /* No need to call _endthreadex(), the actual thread starter routine
+   * in MSVCRT (see crt/src/threadex.c:_threadstartex) calls
+   * _endthreadex() for us.
+   */
+
+  return 0;
+}
+
+
 static void
 create_thread (GIOWin32Channel     *channel,
 	       GIOCondition         condition,
@@ -341,6 +464,8 @@
     g_warning (G_STRLOC ": Error closing thread handle: %s\n",
 	       g_win32_error_message (GetLastError ()));
 
+  SetThreadPriority (thread_handle, THREAD_PRIORITY_HIGHEST);
+
   WaitForSingleObject (channel->space_avail_event, INFINITE);
 }
 
@@ -474,6 +599,80 @@
   return (*bytes_read > 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 }
 
+
+static GIOStatus
+buffer_write (GIOWin32Channel *channel,
+	      const guchar    *dest,
+	      gsize            count,
+	      gsize           *bytes_written,
+	      GError         **err)
+{
+  guint nbytes;
+  guint left = count;
+  
+  LOCK (channel->mutex);
+  if (channel->debug)
+    g_print ("buffer_write: writing to thread %#x %d bytes, rdp=%d, wrp=%d\n",
+	     channel->thread_id, count, channel->rdp, channel->wrp);
+  
+  if ((channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
+    {
+      /* Buffer is full */
+      if (channel->debug)
+	g_print ("buffer_write: tid %#x: resetting data_avail\n",
+		 channel->thread_id);
+      ResetEvent (channel->data_avail_event);
+      if (channel->debug)
+	g_print ("buffer_write: tid %#x: waiting for space\n",
+		 channel->thread_id);
+      UNLOCK (channel->mutex);
+      WaitForSingleObject (channel->data_avail_event, INFINITE);
+      LOCK (channel->mutex);
+      if (channel->debug)
+	g_print ("buffer_write: tid %#x: rdp=%d, wrp=%d\n",
+		 channel->thread_id, channel->rdp, channel->wrp);
+    }
+   
+
+  /* Always leave at least one byte unused gap to be able to
+     distinguish between the full and empty condition.  */
+  nbytes = MIN ((channel->rdp + BUFFER_SIZE - channel->wrp - 1) % BUFFER_SIZE,
+		BUFFER_SIZE - channel->wrp);
+
+  UNLOCK (channel->mutex);
+  nbytes = MIN (left, nbytes);
+  if (channel->debug)
+    g_print ("buffer_write: tid %#x: writing %d bytes\n",
+	     channel->thread_id, nbytes);
+  memcpy (channel->buffer + channel->wrp, dest, nbytes);
+  dest += nbytes;
+  left -= nbytes;
+  LOCK (channel->mutex);
+
+  channel->wrp = (channel->wrp + nbytes) % BUFFER_SIZE;
+  if (channel->debug)
+    g_print ("buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n",
+	     channel->thread_id, channel->rdp, channel->wrp);
+  SetEvent (channel->space_avail_event);
+
+  if ((channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
+    {
+      /* Buffer is full */
+      if (channel->debug)
+	g_print ("buffer_write: tid %#x: resetting data_avail\n",
+		 channel->thread_id);
+      ResetEvent (channel->data_avail_event);
+    }
+
+  UNLOCK (channel->mutex);
+  
+  /* We have no way to indicate any errors form the actual
+     write() call in the writer thread. Should we have?  */
+  *bytes_written = count - left;
+  return (*bytes_written > 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
+}
+
+
 static unsigned __stdcall
 select_thread (void *parameter)
 {
@@ -629,13 +828,27 @@
   if (channel->type == G_IO_WIN32_FILE_DESC)
     {
       LOCK (channel->mutex);
-      if (channel->running && channel->wrp == channel->rdp)
+      if (channel->running)
 	{
-	  if (channel->debug)
-	    g_print ("g_io_win32_prepare: for thread %#x, setting channel->revents = 0\n",
-		     channel->thread_id);
-	  channel->revents = 0;
+	  if (channel->direction == 0 && channel->wrp == channel->rdp)
+	    {
+	      if (channel->debug)
+		g_print ("g_io_win32_prepare: for thread %#x, setting channel->revents = 0\n",
+			 channel->thread_id);
+	      channel->revents = 0;
+	    }
 	}
+      else
+	{
+	  if (channel->direction == 1
+	      && (channel->wrp + 1) % BUFFER_SIZE == channel->rdp)
+	    {
+	      if (channel->debug)
+		g_print ("g_io_win32_prepare: for thread %#x, setting channel->revents = %i\n",
+			 channel->thread_id, 0);
+	      channel->revents = 0;
+	    }
+	}	  
       UNLOCK (channel->mutex);
     }
   else if (channel->type == G_IO_WIN32_SOCKET)
@@ -968,6 +1181,12 @@
   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
   gint result;
   
+  if (win32_channel->thread_id)
+    {
+      return buffer_write (win32_channel, buf, count, bytes_written, err);
+    }
+
+
   result = write (win32_channel->fd, buf, count);
   if (win32_channel->debug)
     g_print ("g_io_win32_fd_write: fd:%d count:%d = %d\n",
@@ -1086,7 +1305,9 @@
 g_io_win32_fd_create_watch (GIOChannel    *channel,
 			    GIOCondition   condition)
 {
-  return g_io_win32_create_watch (channel, condition, read_thread);
+  return g_io_win32_create_watch (channel, condition,
+				  (condition & G_IO_IN)
+				  ? read_thread : write_thread);
 }
 
 static GIOStatus
@@ -1701,8 +1922,13 @@
 
   if (win32_channel->thread_id == 0)
     {
-      if ((condition & G_IO_IN) && win32_channel->type == G_IO_WIN32_FILE_DESC)
-	create_thread (win32_channel, condition, read_thread);
+      if (win32_channel->type == G_IO_WIN32_FILE_DESC)
+	{
+	  if (condition & G_IO_IN)
+	    create_thread (win32_channel, condition, read_thread);
+	  else if (condition & G_IO_OUT)
+	    create_thread (win32_channel, condition, write_thread);
+	}
       else if (win32_channel->type == G_IO_WIN32_SOCKET)
 	create_thread (win32_channel, condition, select_thread);
     }
